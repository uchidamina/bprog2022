GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-05-19 15:47:17.3886566
>>> 34 + 58
92
2022-05-19 15:54:40.9704639
>>> 3 + 5 * 6
33
2022-05-19 15:55:32.0279911
>>> (3 + 5) * 6
48
2022-05-19 15:55:58.4301937
>>> 7 - 3 - 5
-1
2022-05-19 15:56:26.3060429
>>> sprt 2

<interactive>:5:1: error:
    • Variable not in scope: sprt :: t0 -> t
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
2022-05-19 15:59:35.3108294
>>> sprt 2 

<interactive>:6:1: error:
    • Variable not in scope: sprt :: t0 -> t
    • Perhaps you meant ‘sqrt’ (imported from Prelude)
2022-05-19 16:01:11.5654317
>>> sqrt 2
1.4142135623730951
2022-05-19 16:01:41.2765977
>>> sqrt 3
1.7320508075688772
2022-05-19 16:01:45.9322286
>>> double 3

<interactive>:9:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:46.825624
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-06-09 14:55:06.2913147
>>> 2 + 3 * 4
14
2022-06-09 14:58:37.8579326
>>> (2 + 3) * 4
20
2022-06-09 15:00:18.2184774
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:49.6954398
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:05:14.2016064
>>> sqrt (25 :: Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:22.1646676
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:09:38.6020201
>>> sqrt 25
5.0
2022-06-09 15:10:03.9563966
>>> hoge 25 :: Int

<interactive>:8:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:32.5233952
>>> head [1, 2, 3]
1
2022-06-09 15:46:30.7430194
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:46:54.5064979
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:50:46.9736971
>>> hoge
[3,1,4,1,5]
2022-06-09 15:50:57.5340643
>>> head hoge
3
2022-06-09 15:51:33.9591473
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:47.8612438
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:46.1661582
>>> hoge !! 0
3
2022-06-09 15:55:28.792471
>>> hoge !! 2  hoge

<interactive>:17:9: error:
    • No instance for (Num ([Int] -> Int)) arising from the literal ‘2’
        (maybe you haven't applied a function to enough arguments?)
    • In the expression: 2
      In the second argument of ‘(!!)’, namely ‘2 hoge’
      In the expression: hoge !! 2 hoge
2022-06-09 15:56:25.5065179
>>> hoge !! 2
4
2022-06-09 15:56:40.8943067
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:55.7827433
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:29.590724
>>> hoge 5hoge

<interactive>:21:1: error:
    • Couldn't match expected type: t0 -> [Int] -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to two value arguments,
        but its type ‘[Int]’ has none
      In the expression: hoge 5 hoge
      In an equation for ‘it’: it = hoge 5 hoge
    • Relevant bindings include it :: t (bound at <interactive>:21:1)
2022-06-09 15:58:28.4019902
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:55.3608862
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:23.7485793
>>> drop 10 hoge
[]
2022-06-09 15:59:52.0361886
>>> length hoge
5
2022-06-09 16:01:05.5481565
>>> length []
0
2022-06-09 16:01:25.7348785
>>> sum hoge
14
2022-06-09 16:02:10.5186345
>>> product hoge
60
2022-06-09 16:03:21.5237674
>>> hoge ++ hoge[

<interactive>:29:14: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 16:04:50.9540347
>>> 
2022-06-09 16:04:51.1094505
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:05:09.6463392
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:40.896885
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, no modules loaded.
2022-06-09 16:08:15.158502
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:08:15.2322798
>>> double 3 + 3
9
2022-06-09 16:09:15.6984169
>>> double (3 + 3)
12
2022-06-09 16:11:30.5992642
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:14:21.5683011
>>> quadruple 2
8
2022-06-09 16:14:41.7287979
>>> quadruple (2 + 3)
20
2022-06-09 16:15:15.1195955
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-06-16 15:02:06.3069816
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:05:40.2987401
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:46.3492775
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:46.4093831
>>> 
2022-06-16 15:11:35.8765248
>>> double

<interactive>:5:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:12:54.311803
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:53.2825408
>>> 
2022-06-16 15:20:15.4341559
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:33.1826461
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:21:02.7066438
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: integer -> integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:10:15: error:
    • No instance for (Num integer) arising from a use of ‘product’
      Possible fix:
        add (Num integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |               ^^^^^^^^^^^^^^^^

src/First.hs:10:23: error:
    • No instance for (Enum integer)
        arising from the arithmetic sequence ‘1 .. n’
      Possible fix:
        add (Enum integer) to the context of
          the type signature for:
            factorial :: forall integer. integer -> integer
    • In the first argument of ‘product’, namely ‘[1 .. n]’
      In the expression: product [1 .. n]
      In an equation for ‘factorial’: factorial n = product [1 .. n]
   |
10 | factorial n = product [1 .. n]
   |                       ^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:21:27.9871907
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:23:08.3828819
>>> factorisl 3

<interactive>:12:1: error:
    • Variable not in scope: factorisl :: t0 -> t
    • Perhaps you meant ‘factorial’ (line 10)
2022-06-16 15:23:32.814957
>>> factorial 3
6
2022-06-16 15:24:26.6575661
>>> factorial 4
24
2022-06-16 15:24:44.1265978
>>> 
2022-06-16 15:38:14.9393563
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:27: error:
    • Couldn't match expected type ‘Int’
                  with actual type ‘t0 a0 -> Int’
    • Probable cause: ‘length’ is applied to too few arguments
      In the second argument of ‘div’, namely ‘length’
      In the expression: sum xs `div` length
      In an equation for ‘average’: average xs = sum xs `div` length
   |
13 | average xs = sum xs `div` length
   |                           ^^^^^^
Failed, no modules loaded.
2022-06-16 15:38:20.9358647
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:38:56.0048699
>>> average [1,2,3,4,5]
3
2022-06-16 15:39:26.5320536
>>> 
2022-06-16 15:47:24.1112197
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:50:04.9757213
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:10.7986663
>>> myinit [1 .. 5]

<interactive>:22:1: error:
    • Variable not in scope: myinit :: [a0] -> t
    • Perhaps you meant ‘init’ (imported from Prelude)
2022-06-16 16:14:50.8836938
>>> myinit [1 .. 5]

<interactive>:23:1: error:
    • Variable not in scope: myinit :: [a0] -> t
    • Perhaps you meant ‘init’ (imported from Prelude)
2022-06-16 16:15:13.9935275
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:15:31.5730837
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:15:46.2975323
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-06-23 14:56:20.2400495
>>> clear

<interactive>:1:1: error: Variable not in scope: clear
2022-06-23 14:56:59.3224313
>>> clear

<interactive>:2:1: error: Variable not in scope: clear
2022-06-23 14:57:14.588273
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-06-23 14:57:37.6839791
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:57:53.4583208
>>> 1 == 2
False
2022-06-23 15:06:12.5685862
>>> 1 < 2
True
2022-06-23 15:06:28.1728715
>>> 1 < 1
False
2022-06-23 15:06:35.217888
>>> 1 <= 2
True
2022-06-23 15:06:43.606145
>>> 1 >= 2
False
2022-06-23 15:06:57.9518181
>>> 'a' < 'b'
True
2022-06-23 15:11:19.9327688
>>> 'a' < 'B'
False
2022-06-23 15:11:43.4709741
>>> 1 /= 1
False
2022-06-23 15:16:59.7457439
>>> 1 /= 2
True
2022-06-23 15:17:10.885909
>>> :i abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:26.4396928
>>> abs (-234)
234
2022-06-23 15:34:38.3397384
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-06-30 14:56:16.6447481
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:01:49.4933419
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:05:07.4932837
>>> 2022-06-30 15:11:36.6399008
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-06-30 15:12:30.6067041
>>> [ x `div` 2 | x <- [1 .. 5]]
[0,1,1,2,2]
2022-06-30 15:13:20.4362774
>>> 
2022-06-30 15:13:38.8884194
>>> 
2022-06-30 15:15:38.4278385
>>> [ x `divMod` 2 | x <- [1 .. 5]]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:16:31.6510175
>>> [ (x, y) | x <- "abc", y <- [4,5] ]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:20:50.7845311
>>> [ (x, y) | y <- [4,5],  x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:22:12.4280116
>>> 
2022-06-30 15:27:20.9843514
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:11:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:28:42.5901317
>>> myconcat [[1,2,3],[4,5],[6,7,8,9]]

<interactive>:12:1: error:
    • Variable not in scope: myconcat :: [[a0]] -> t
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:31:26.6194396
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:31.8532391
>>> mylength ['a' .. 'z']

<interactive>:14:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-06-30 15:50:59.3060337
>>> 
2022-06-30 15:51:36.0418079
>>> mylength ['a' .. 'z']

<interactive>:16:1: error:
    • Variable not in scope: mylength :: [Char] -> t
    • Perhaps you meant ‘length’ (imported from Prelude)
2022-06-30 15:52:32.3207967
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-07-07 16:05:07.9091718
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:05:51.1106184
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:05:51.1847816
>>> ord 'A'
65
2022-07-07 16:06:21.5973965
>>> ord 'a'
97
2022-07-07 16:06:33.1378627
>>> 
2022-07-07 16:11:19.9854296
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-07-14 15:11:19.4032691
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c
Ok, no modules loaded.
2022-07-14 15:11:49.4558751
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:11:49.5289617
>>> let2int 'a'
97
2022-07-14 15:12:41.2559631
>>> let2int 'z'
122
2022-07-14 15:13:32.0808555
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:19.4921663
>>> let2int 'a'
0
2022-07-14 15:15:32.2101292
>>> let2int 'z'
25
2022-07-14 15:15:50.4572312
>>> ord 'a'
97
2022-07-14 15:19:15.7278418
>>> chr 97
'a'
2022-07-14 15:19:31.0321822
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:29.3173244
>>> int2let 0
'a'
2022-07-14 15:20:39.2382202
>>> int2let 25
'z'
2022-07-14 15:20:51.3127808
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      |otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |     ^
Failed, no modules loaded.
2022-07-14 15:27:44.3471466
>>> shift 3 'a'

<interactive>:14:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:28:10.3183397
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13      | isLower c = int2let ((let2int c + n) 'mod' 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) 'mod' 26)
   |     ^
Failed, no modules loaded.
2022-07-14 15:28:34.5648404
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c = 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:5: error: parse error on input ‘|’
   |
13 |     | isLower c = int2let ((let2int c + n) `mod` 26)
   |     ^
Failed, no modules loaded.
2022-07-14 15:29:52.2953239
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:30:47.7307646
>>> shift 3 'a'
'd'
2022-07-14 15:31:36.2977222
>>> shift (-3) 'd'
'a'
2022-07-14 15:32:00.0583569
>>> shift 3 'z'
'c'
2022-07-14 15:32:15.8352802
>>> shift 3 ' '
' '
2022-07-14 15:32:58.4421166
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:35:59.1829413
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:36:29.7029762
>>> 
2022-07-14 15:47:51.3556838
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:02.9995939
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:48:17.5452281
>>> encode(- 3) it
"haskell is fun"
2022-07-14 15:49:07.7155966
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24          
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:59:17.6573696
>>> length table
26
2022-07-14 15:59:50.5610921
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:48.3143497
>>> percent 5 15
33.333336
2022-07-14 16:09:09.2290167
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:48.9686361
>>> count 's' "Mississppi"
4
2022-07-14 16:15:54.4753201
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-07-21 15:06:11.1335048
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
Ok, no modules loaded.
2022-07-21 15:06:41.139107
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:06:41.3771574
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:20:21.7692624
>>> :l
Ok, no modules loaded.
2022-07-21 15:20:21.7879222
>>> length sample

<interactive>:5:8: error: Variable not in scope: sample :: t0 a0
2022-07-21 15:20:49.7433713
>>> length sample

<interactive>:6:8: error: Variable not in scope: sample :: t0 a0
2022-07-21 15:21:38.9509465
>>> sample

<interactive>:7:1: error: Variable not in scope: sample
2022-07-21 15:22:18.848444
>>> :e Caesar.hs
catn: Caesar.hs: openFile: does not exist (No such file or directory)
2022-07-21 15:22:46.0334436
>>> :l Caesar.hs

<no location info>: error: can't find file: Caesar.hs
Failed, no modules loaded.
2022-07-21 15:22:46.1379778
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/mina/bprog2022/.ghci
2022-07-21 15:23:13.8837197
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
Ok, no modules loaded.
2022-07-21 15:23:41.8889385
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:23:42.0710016
>>> length sample
15
2022-07-21 15:24:08.3974957
>>> sample
"abbcccddddeeeee"
2022-07-21 15:24:20.1939738
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-21 15:24:38.8834442
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:39:17.132459
>>> :l
Ok, no modules loaded.
2022-07-21 15:39:17.2051392
>>> rotate 3 [1,2,3,4,5]

<interactive>:8:1: error:
    Variable not in scope: rotate :: t0 -> [a0] -> t
2022-07-21 15:40:03.4665883
>>> :e
No files to edit.
2022-07-21 15:40:21.7127272
>>> :l
Ok, no modules loaded.
2022-07-21 15:40:21.8137106
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
Ok, no modules loaded.
2022-07-21 15:40:53.3826094
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:40:53.5012247
>>> rotate 3 [1,2,3,4,5]
[4,5,1,2,3]
2022-07-21 15:41:11.8857659
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:46:18.7045713
>>> table'
[0.0,0.0,0.0,7.1428576,0.0,0.0,0.0,7.1428576,7.1428576,0.0,7.1428576,7.1428576,0.0,7.1428576,14.285715,0.0,7.1428576,0.0,0.0,0.0,0.0,14.285715,0.0,7.1428576,0.0,0.0]
2022-07-21 15:46:34.1344054
>>> [chisqr (rotate n table') table | n <- [0 .. 25] ]
[1037.1161,472.26096,451.96503,150.75772,1059.9601,3122.5193,480.326,857.7907,716.2974,731.72504,367.52783,1095.8976,1689.1488,1036.0608,1097.8545,2231.09,486.6004,2085.8784,725.49756,596.9133,964.8147,627.002,2138.5535,703.25635,3905.8936,462.25485]
2022-07-21 15:48:14.3026337
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:24: error:
    Variable not in scope: positions :: Float -> [Float] -> [a]
   |
54 |         factor = head (positions (minimum chitab) chitab)
   |                        ^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:54:53.2588768
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:58:38.9530282
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          ,0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          ,6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100    
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  freqs :: String -> [Float]
  31  
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 / e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs sampleAngou
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions (minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:59:56.2034585
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:01:02.2466775
>>> crack sampleAngou
"haskell is fun"
2022-07-21 16:03:38.716381
>>> crack "vscd mywzboroxcsyxc kbo ecopev"
"list comprehensions are useful"
2022-07-21 16:05:23.2660467
>>> :q
Leaving GHCi.
